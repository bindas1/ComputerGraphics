<!doctype html>
<!-- pandoc readme.md --template page_template.html -o page.html 
 -->
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title> ICG Exercise 4 - Geometric transforms in the GPU pipeline </title>
<style>
* {
	box-sizing: border-box;
}

body {
	width: 100%;
	padding: 0;
	margin: 0;
	border: 0;

	max-width: 60rem;
	margin-left: auto;
	margin-right: auto;

	font-family: sans-serif;
	font-size: 1.1rem;
	line-height: 120%;

	text-align: justify;
}

h1, h2, h3, h4, h5, h6, a
{
	/* color: rgb(50, 90, 200); */
	color: hsl(138, 70%, 25%);

}
h3, h4, h5, h6 {
	font-weight: normal;
}

p, ul {
	margin-left: 1.5rem;
	margin-right: 1.5rem;
}

h3, h4, h5, h6 { 
	margin-left: 1rem;
}

h3 {}

ul {
	padding-left: 1.5rem;
}

h2 {
	margin-top: 5rem;
	padding: 1rem;

	width: 100%;

	/* background: linear-gradient(90deg, white, rgb(50, 50, 200)); */
	border: solid 2px hsl(138, 70%, 25%);
	/* background: rgb(200, 200, 255) */
	border-radius: 1.5rem;
}

h1 { font-size: 2rem; }
h2 { font-size: 1.75rem; }
h3 { font-size: 1.4rem; }
h4 { font-size: 1.05rem; }

body > img {
	display: block;
	margin-left: auto;
	margin-right: auto;
}

code {
	color: rgb(0, 44, 122);
}

figure {
	margin: 0.5rem;
	width: 100%;
	max-width: 100%;

	max-height: 30rem;

	display: flex;
	flex-flow: row;
	justify-content: center;
	justify-items: space-between;
}

figure img {
	object-fit: contain;
	max-width: inherit;
	max-height: inherit;
	height: 100%;

	margin-left: 1rem;
	margin-right: 1rem;
}

figure a {
	max-width: inherit;
	max-height: inherit;
}

.box {
	margin-left: 1rem;
	border: 0.1rem solid;
	border-top: 0.3rem solid;
	border-radius: 0.5rem;
	padding-left: 0.5rem;
	padding-right: 0.5rem;
	margin-bottom: 0.5rem;
}
.box.practice {
	border-color: hsl(182, 100%, 60%);
	background: hsla(182, 100%, 60%, 0.05)
}
.box.task {
	border-color: hsl(41, 100%, 40%);
	background: hsla(41, 100%, 40%, 0.05)
}
.box.grade {
	border-color: hsl(12, 100%, 40%);
	background: hsla(12, 100%, 40%, 0.05)
}

.box h2,
.box h3,
.box h4,
.box h5 {
	color: black;
}

/* img {
	max-width: 100%;
} */

div.sourceCode {
	background: hsla(0, 0%, 0%, 0.05);
	border-radius: 0.5rem;
	/* border: hsla(0, 0%, 0%, 0.15) 1px dashed; */
}
pre.sourceCode {
	font-size: 0.9rem;
	margin-left: 2rem;
}

code.sourceCode, .sourceCode a {
	color: black;
}

pre.sourceCode

/* code span.al { color: #ef2929; } /* Alert */
code span.an { color: black; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: hsl(215, 77%, 12%); } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: hsl(215, 77%, 12%); font-weight: bold; } /* ControlFlow */
code span.ch { color: #204a87;; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: hsl(118, 100%, 12%); font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #204a87; } /* SpecialString */
code span.st { color: #204a87; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #204a87; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */

  </style>

</style>
</head>

<body>

<h1 id="icg-exercise-4-geometric-transforms-in-the-gpu-pipeline">ICG Exercise 4: Geometric transforms in the GPU pipeline</h1>
<p><nav></p>
<ul>
<li><a href="#practice-console-and-debugger">Practice 0.1 - JS Console and Debugger</a></li>
<li><a href="#practice-gl-matrix-in-the-console">Practice 0.2 - gl-matrix</a></li>
<li><a href="#task-1.1-2d-translation-in-shader">Task 1.1 - 2D translation in shader</a></li>
<li><a href="#task-1.2-2d-matrix-transform">Task 1.2 - 2D matrix-transform</a></li>
<li><a href="#task-2.1-mvp-matrix">Task 2.1 - Model-view-projection</a></li>
<li><a href="#task-2.2-view-matrix">Task 2.2 - View matrix</a></li>
<li><a href="#task-2.3-model-matrix">Task 2.3 - Model matrix</a> </nav></li>
</ul>
<figure>
<img src="doc/icg_solar_title.jpg"></img>
</figure>
<h2 id="web-technologies">Web technologies</h2>
<p>The exercises involving the GPU pipeline will be implemented as web-applications run in a browser. The GPU API available in the browser is called <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>. Since WebGL is not convenient to use directly, we take advantage of the <a href="https://github.com/regl-project/regl">regl.js</a> library which allows us to configure the GPU pipeline in a declarative way.</p>
<p>In previous years, the exercises were implementing using C++ and OpenGL, but we have made the change due to the following reasons:</p>
<ul>
<li>Nothing to install</li>
<li>No compilation step, refresh page to run again</li>
<li>Convenient API of <a href="https://github.com/regl-project/regl/blob/gh-pages/API.md">regl.js</a></li>
<li>Projects can be easily shared on the web</li>
<li>C++/OpenGL errors are hard to resolve</li>
</ul>
<p>We believe the raw OpenGL API is too low-level and stateful, making the core concept of the GPU pipeline hard to see. The OpenGL version of this exercise involved around 30 source files, while this WeblGL+regl version is about 400 lines total. We hope this will help you learn and empower you to create even more amazing projects.</p>
<h3 id="application-structure">Application structure</h3>
<p>The main parts of a web-application are:</p>
<ul>
<li>an HTML document, the content of the website</li>
<li>JavaScript code run in the browser, makes the application interactive.</li>
</ul>
<p>In our exercises, the HTML is very simple and only contains the WebGL viewport (<code>&lt;canvas&gt;</code>) and some overlays where we can display text. The document references the JavaScript files which are executed by the application <code>&lt;script src="src/main.js"&gt;</code>.</p>
<p>Here are the files you will find in this exercise:</p>
<ul>
<li><code>index_2d_transform.html</code> - The file we open in browser. Specifies the layout of the application and links to the JavaScript code to load such as <code>&lt;script src="src/main.js"&gt;</code>. This file is for the 2D part (part 1)</li>
<li><code>index.html</code> - same as above but for the 3D part (part 2)</li>
<li><code>src</code> - Code you will be editing and the code we provide.
<ul>
<li><code>main_2d_transform.js</code> - Rendering code for the 2D version. Edit this file in part 1 of the exercise.</li>
<li><code>main.js</code> - Rendering code for the 3D version. Edit this file in part 2 of the exercise.</li>
<li><code>icg_web.js</code> - Provided code: interfacing with web APIs, such as keyboard input.</li>
<li><code>icg_mesh.js</code> - Provided code: construction and loading of triangle meshes.</li>
<li><code>icg_math.js</code> - Provided code: additional matrix/vector utilities.</li>
<li><code>icg_grid.js</code> - Provided code: draws a grid at Z=0 to help you debug your 3D transforms.</li>
</ul></li>
<li><code>lib</code> - external libraries
<ul>
<li><a href="https://github.com/regl-project/regl">regl.js</a> - GPU API</li>
<li><a href="http://glmatrix.net/docs/">gl-matrix</a> - vector and matrix operations.</li>
</ul></li>
<li><code>style.css</code> - specifies the appearance of the application <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">what is CSS</a>.</li>
</ul>
<h3 id="javascript-development-console-and-debugger">JavaScript development, Console and debugger</h3>
<p>Our code runs in the browser, and therefore we use the JavaScript language. The syntax is somewhat similar to C++, but JS is dynamically typed and does not have a compilation step. About JavaScript on this course:</p>
<ul>
<li><em>The exercises do not involve advanced JS programming - we will mostly work on the GPU and the JS part only prepares the matrices and meshes for it.</em></li>
<li>If you are new to JS, it is worth practicing with a tutorial, for example <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript on MDN</a>. Web development is very popular now and you are bound to run into it sooner or later.</li>
<li>We try to explain as much as we can in the exercise code comments. Reading the whole file, beyond the parts you fill in, should make everything more understandable.</li>
</ul>
<p>We only need a code editor and a browser (we test the exercises for Firefox and Chromium). Let us start by <em>opening index_2d_transform.html in your browser</em>.</p>
<p>The browser’s <strong>developer tools</strong> are a critical resource for web development: <a href="https://developer.mozilla.org/en-US/docs/Tools">dev tools in FireFox</a>, <a href="https://developers.google.com/web/tools/chrome-devtools">dev tools in Chrome</a>.</p>
<p>The <em>Console</em> (<a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">Firefox</a>, <a href="https://developers.google.com/web/tools/chrome-devtools/console">Chrome</a>) is where any errors or logs are written. Whenever your are running the application, you should have it open. In JS, you can log messages and objects to the console with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log">console.log(x)</a>.</p>
<p>In the <em>Debugger</em> (<a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox</a>, <a href="https://developers.google.com/web/tools/chrome-devtools/javascript">Chrome</a>), you can set breakpoints (place where the program pauses) and inspect the variables’ values.</p>
<p>If you are new to these tools, we recommend you look at the tutorials - we can not hope to explain better than them. With the web playing a big part in the modern world, we believe the underlying technologies are worth knowing, even if they are not directly relevant to this graphics course.</p>
<h4 id="possible-surprises-of-javascript">Possible surprises of JavaScript:</h4>
<ul>
<li><p><strong>semicolons</strong> in JS are put in the same places as in C++, but are optional - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Automatic_semicolon_insertion">the parser will usually understand the code without them</a>. In rare cases having no semicolon at the end of line, or having extra newlines, can <a href="https://flaviocopes.com/javascript-automatic-semicolon-insertion/">cause unexpected errors</a>.</p></li>
<li><p><strong>functions</strong>. <code>(x) =&gt; { ... }</code> is a function defined using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow syntax</a>. Functions are first-class objects in JS and they are often stored in variables of passed as arguments. A function created inside another function has access to the parent’s variables - this is called a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">closure</a>. We use this in our framework often, for example to edit <code>mouse_offset</code> in the mouse-move handler function.</p></li>
<li><p><strong>variables</strong> are dynamically typed - they can take objects of any type. <code>let x = [0, 0, 0];</code> declares a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">rebindable variable</a> and <code>const y = [0, 0, 0];</code> declares a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">non-rebindable variable</a>. That is, we can do <code>x = 1;</code> but can not do <code>y = 1;</code>. However, unlike C++, the object in <code>const</code> variable can be modified - we can do <code>y[0] = 1</code>; There is also <code>var</code> which is now obsolete, it works like <code>let</code> but ignores scope.</p></li>
</ul>
<div class="box practice">
<h4 id="practice-console-and-debugger">Practice: Console and debugger</h4>
<ul>
<li>Open <code>index_2d_transform.html</code> in your browser</li>
<li>Open the Console, try some basic variables and operations. Press Enter after each line, for example:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">let</span> y <span class="op">=</span> x<span class="op">+</span><span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3">x</a>
<a class="sourceLine" id="cb1-4" title="4">y</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="vs">`</span><span class="sc">${</span>x<span class="sc">}</span><span class="vs"> + 5 = </span><span class="sc">${</span>y<span class="sc">}</span><span class="vs">`</span></a></code></pre></div>
<ul>
<li>Edit <code>src/main_2d_transform.js</code>, add <code>console.log(frame)</code> inside the per-frame function (<code>regl.frame((frame) =&gt; { ...here... }</code>) to print frame properties into the console.</li>
<li>Put a break-point in the render function, inspect the variables.</li>
</ul>
</div>
<h2 id="gpu-pipeline">GPU Pipeline</h2>
<p>Rasterization is performed on a GPU (graphics card). GPUs are specialized in massively parallel processing of mesh geometry and image pixels. They operate according to a specific pipeline,</p>
<p><a href="https://www.gamedev.net/tutorials/programming/graphics/introduction-to-the-graphics-pipeline-r3344/">Introduction to the Graphics Pipeline</a></p>
<p><strong>GPU pipeline inputs</strong></p>
<ul>
<li><em>Vertex attributes</em>: position, normal, texture coordinates…</li>
<li><em>Faces</em>: triangles of the mesh, stored as triples of indices</li>
<li><em>Uniforms</em>: data globally available to the GPU programs, it includes textures</li>
</ul>
<p><strong>GPU processing steps</strong> * <em>Vertex shader</em>: program executed for each vertex of the mesh, calculates its position in the image, and intermediate variables used by the fragment shader. * <em>Fragment shader</em>: program executed for each output pixel of the mesh, calculates the pixel’s output color.</p>
<h3 id="regl.js-pipeline-specification">regl.js pipeline specification</h3>
<p>Let us look at the pipeline declaration in regl.js. First the pipeline is constructed with the data which does not change during runtime. This construction step is expensive and should be done only once. We mark values which change in time using <code>regl.prop('prop_name')</code> - we will be able to supply them later when executing the pipeline.</p>
<p>At each frame, we execute the pipeline and provide the dynamic values <code>draw({prop_name: ...})</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> regl <span class="op">=</span> <span class="at">createREGL</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">// The pipeline is constructed only once!</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">const</span> draw_triangle <span class="op">=</span> <span class="at">regl</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="co">// Vertex attributes - properties of each vertes such as position, normal, texture coordinates...</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="dt">attributes</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="co">// 3 vertices with 2 coordinates each</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="dt">position</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb2-10" title="10">            [<span class="dv">0</span><span class="op">,</span> <span class="fl">0.2</span>]<span class="op">,</span> <span class="co">// [x, y] - vertex 0</span></a>
<a class="sourceLine" id="cb2-11" title="11">            [<span class="op">-</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">-0.2</span>]<span class="op">,</span> <span class="co">// [x, y] - vertex 1</span></a>
<a class="sourceLine" id="cb2-12" title="12">            [<span class="fl">0.2</span><span class="op">,</span> <span class="fl">-0.2</span>]<span class="op">,</span> <span class="co">// [x, y] - vertex 2</span></a>
<a class="sourceLine" id="cb2-13" title="13">        ]<span class="op">,</span></a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="op">},</span></a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="co">// Triangles (faces), as triplets of vertex indices</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="dt">elements</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb2-18" title="18">        [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">,</span> <span class="co">// one triangle here</span></a>
<a class="sourceLine" id="cb2-19" title="19">    ]<span class="op">,</span></a>
<a class="sourceLine" id="cb2-20" title="20">    </a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="co">// Uniforms: global data available to the shader</span></a>
<a class="sourceLine" id="cb2-22" title="22">    <span class="dt">uniforms</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-23" title="23">        <span class="dt">color</span><span class="op">:</span> <span class="va">regl</span>.<span class="at">prop</span>(<span class="st">&#39;color&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="op">},</span>  </a>
<a class="sourceLine" id="cb2-25" title="25"></a>
<a class="sourceLine" id="cb2-26" title="26">    <span class="co">/* </span></a>
<a class="sourceLine" id="cb2-27" title="27"><span class="co">    Fragment shader program</span></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="co">    Calculates the color of each pixel covered by the mesh.</span></a>
<a class="sourceLine" id="cb2-29" title="29"><span class="co">    The &quot;varying&quot; values are interpolated between the values </span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="co">    given by the vertex shader on the vertices of the current triangle.</span></a>
<a class="sourceLine" id="cb2-31" title="31"><span class="co">    */</span></a>
<a class="sourceLine" id="cb2-32" title="32">    <span class="dt">vert</span><span class="op">:</span> <span class="vs">`</span></a>
<a class="sourceLine" id="cb2-33" title="33"><span class="vs">    // Vertex attributes, specified in the &quot;attributes&quot; entry of the pipeline</span></a>
<a class="sourceLine" id="cb2-34" title="34"><span class="vs">    attribute vec2 position;</span></a>
<a class="sourceLine" id="cb2-35" title="35"><span class="vs">            </span></a>
<a class="sourceLine" id="cb2-36" title="36"><span class="vs">    void main() {</span></a>
<a class="sourceLine" id="cb2-37" title="37"><span class="vs">        // [x, y, 0, 1]</span></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="vs">        gl_Position = vec4(position, 0, 1);</span></a>
<a class="sourceLine" id="cb2-39" title="39"><span class="vs">    }`</span><span class="op">,</span></a>
<a class="sourceLine" id="cb2-40" title="40">    </a>
<a class="sourceLine" id="cb2-41" title="41">    <span class="co">/* </span></a>
<a class="sourceLine" id="cb2-42" title="42"><span class="co">    Vertex shader program</span></a>
<a class="sourceLine" id="cb2-43" title="43"><span class="co">    Given vertex attributes, it calculates the position of the vertex on screen</span></a>
<a class="sourceLine" id="cb2-44" title="44"><span class="co">    and intermediate data (&quot;varying&quot;) passed on to the fragment shader</span></a>
<a class="sourceLine" id="cb2-45" title="45"><span class="co">    */</span></a>
<a class="sourceLine" id="cb2-46" title="46">    <span class="dt">frag</span><span class="op">:</span> <span class="vs">`</span></a>
<a class="sourceLine" id="cb2-47" title="47"><span class="vs">    precision mediump float;</span></a>
<a class="sourceLine" id="cb2-48" title="48"><span class="vs">    </span></a>
<a class="sourceLine" id="cb2-49" title="49"><span class="vs">    uniform vec3 color;</span></a>
<a class="sourceLine" id="cb2-50" title="50"></a>
<a class="sourceLine" id="cb2-51" title="51"><span class="vs">    void main() {</span></a>
<a class="sourceLine" id="cb2-52" title="52"><span class="vs">        // [R, G, B, 1]</span></a>
<a class="sourceLine" id="cb2-53" title="53"><span class="vs">        gl_FragColor = vec4(color, 1.); // output: RGBA in 0..1 range</span></a>
<a class="sourceLine" id="cb2-54" title="54"><span class="vs">    }`</span><span class="op">,</span></a>
<a class="sourceLine" id="cb2-55" title="55"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-56" title="56"></a>
<a class="sourceLine" id="cb2-57" title="57"><span class="co">// Function run to draw each frame</span></a>
<a class="sourceLine" id="cb2-58" title="58"><span class="va">regl</span>.<span class="at">frame</span>((frame) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-59" title="59">    <span class="co">// Reset the canvas to black</span></a>
<a class="sourceLine" id="cb2-60" title="60">    <span class="va">regl</span>.<span class="at">clear</span>(<span class="op">{</span><span class="dt">color</span><span class="op">:</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-61" title="61">        </a>
<a class="sourceLine" id="cb2-62" title="62">    <span class="co">// Execute the declared pipeline</span></a>
<a class="sourceLine" id="cb2-63" title="63">    <span class="at">draw_triangle</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb2-64" title="64">        <span class="dt">color</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>]<span class="op">,</span> <span class="co">// provide the value for regl.prop(&#39;color&#39;) in uniforms.</span></a>
<a class="sourceLine" id="cb2-65" title="65">    <span class="op">}</span>)</a>
<a class="sourceLine" id="cb2-66" title="66"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h3 id="shaders">Shaders</h3>
<p><em>Shaders</em> are programs which run on the GPU. They have their own language, GLSL, which is quite similar to C, with the added <a href="http://www.shaderific.com/glsl-types">vector and matrix types</a>.<br />
<a href="http://www.shaderific.com/glsl/">GLSL reference</a><br />
<a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">WebGL reference card</a> page 3-4</p>
<p>The pipeline contains two shader programs: * <em>Vertex shader</em>: executed for each vertex of the mesh, calculates its position in the image, and intermediate variables used by the fragment shader. * <em>Fragment shader</em>: program executed for each output pixel of the mesh, calculates the pixel’s output color.</p>
<h4 id="vertex-shader">Vertex shader</h4>
<p>The vertex shader receives as input the vertex attributes specified in the <code>attributes:</code> section. They have to be declared with the <code>attribute</code> keyword.</p>
<p>It can pass per-vertex data to the fragment shader, such variables are specified by the <code>varying</code> keyword. The <code>varying</code> values are interpolated between the triangle’s three vertices weighted by barycentric coordinates.</p>
<p>The vertex shader writes the vertex <em>image</em> coordinates to <code>gl_Position</code> which is a <code>vec4</code> (<a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogenous coordinates</a>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl"><code class="sourceCode glsl"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// Vertex attributes, specified in the &quot;attributes&quot; entry of the pipeline</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">attribute</span> <span class="dt">vec3</span> position;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">// Intermediate value passed on to fragment shader</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="dt">varying</span> <span class="dt">vec2</span> tex_coord;</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="dt">void</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="co">// intermediate value passed on to fragment shader</span></a>
<a class="sourceLine" id="cb3-9" title="9">    tex_coord = position.<span class="fu">xy</span>;</a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="co">// output position [x, y, z, 1]</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(position, <span class="dv">1</span>);    </a>
<a class="sourceLine" id="cb3-12" title="12">}</a></code></pre></div>
<h4 id="fragment-shader">Fragment shader</h4>
<p>It can receive data from the vertex shader, such variables are specified by the <code>varying</code> keyword in both shaders. The <code>varying</code> values are interpolated between the triangle’s three vertices weighted by barycentric coordinates.</p>
<p>The fragment shader writes the pixel color to <code>gl_FragColor</code> as <code>vec4(Red, Green, Blue, Opacity)</code>.</p>
<p>Both vertex and fragment shader have access to the global <code>uniform</code> values.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl"><code class="sourceCode glsl"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// numerical precision of calculation, no consensus which one to use</span></a>
<a class="sourceLine" id="cb4-2" title="2">precision mediump <span class="dt">float</span>; </a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">// Intermediate value from vertex shader have to be declared in both shaders</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">varying</span> <span class="dt">vec2</span> tex_coord;</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">// Access global values from the uniforms: section</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">uniform</span> <span class="dt">vec3</span> color;</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="dt">void</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="co">// [R, G, B, 1] in 0..1 range</span></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="va">gl_FragColor</span> = <span class="dt">vec4</span>(color, <span class="fl">1.</span>);</a>
<a class="sourceLine" id="cb4-13" title="13">}</a></code></pre></div>
<h2 id="matrix-operations-gl-matrix">Matrix operations, gl-matrix</h2>
<p>For matrix and vector operations, we will be using <a href="http://glmatrix.net/">gl-matrix</a>, which is a simple library similar to the <code>vec3.h</code> file in the C++ exercise. The code of the library is quite straight-forward, see for example the <a href="https://github.com/toji/gl-matrix/blob/master/src/mat4.js">gl-matrix file mat4.js</a>. We primarily use the 4x4 matrices to express transformation in 3D space - <a href="http://glmatrix.net/docs/module-mat4.html">mat4 documentation</a>.</p>
<h3 id="differences-from-c">Differences from C++</h3>
<p><strong>Functions instead of operators:</strong> JavaScript does not have <a href="https://en.wikipedia.org/wiki/Operator_overloading">operator overloading</a>, so unlike C++ we can not express matrix multiplication with <code>*</code>.</p>
<p><strong>Printing:</strong> Matrices and vectors are both stored as flat arrays, so a 4x4 matrix is a 16-element array. This array is what you will see if you <code>console.log(matrix)</code>. Use <code>mat4_to_string(m, decimals)</code> to format the string in a readable form.</p>
<p><strong>Output argument:</strong> gl-matrix has been designed for fast performance and so it tries to reuse the matrix objects instead of creating new ones (objects have to be then cleared out by the garbage collector). Therefore in nearly all its functions, the first argument is the output object to which the result is written.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> M_rotation <span class="op">=</span> <span class="va">mat4</span>.<span class="at">create</span>()<span class="op">;</span> <span class="co">// allocate matrix</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// set matrix to 45 deg rotation around Z axis</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="va">mat4</span>.<span class="at">fromZRotation</span>(M_rotation<span class="op">,</span> <span class="dv">45</span> <span class="op">*</span> <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">const</span> C <span class="op">=</span> <span class="va">mat4</span>.<span class="at">create</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// multiply: C = A * B</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="va">mat4</span>.<span class="at">multiply</span>(C<span class="op">,</span> A<span class="op">,</span> B)<span class="op">;</span></a></code></pre></div>
<p>You do not have to reuse the matrices - in our application the performance loss is insignificant.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// allocate a new matrix for the result</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> M_rotation <span class="op">=</span> <span class="va">mat4</span>.<span class="at">fromZRotation</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> <span class="dv">45</span> <span class="op">*</span> <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span>)<span class="op">;</span> </a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">// and</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">const</span> C <span class="op">=</span> <span class="va">mat4</span>.<span class="at">multiply</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> A<span class="op">,</span> B)<span class="op">;</span></a></code></pre></div>
<p>You <em>can</em> do operations <em>in-place</em>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="va">mat4</span>.<span class="at">multiply</span>(A<span class="op">,</span> A<span class="op">,</span> B)<span class="op">;</span> <span class="co">// A = A*B</span></a></code></pre></div>
<h3 id="extra-utilities">Extra utilities</h3>
<p>Since gl-matrix is very basic, we are adding some convenience utilities in <code>src/icg_math.js</code>.</p>
<ul>
<li><p><code>matrix.get(row, col)</code> - get element (row and col and 0-indexed)</p></li>
<li><p><code>matrix.set(row, col, value)</code> - set element (row and col and 0-indexed)</p></li>
<li><p><code>mat4_matmul_many</code> - Multiply any number of matrices:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="co">//out = m1 * m2 * m3 * ...</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="at">mat4_matmul_many</span>(out<span class="op">,</span> m1<span class="op">,</span> m2<span class="op">,</span> m3<span class="op">,</span> ...)</a></code></pre></div></li>
<li><p><code>vec_to_string(vector, decimals)</code> - display a vector with fixed decimal places</p></li>
<li><p><code>matrix.toString()</code> - reprent a matrix as a human-readable string</p></li>
</ul>
<div class="box practice">
<h4 id="practice-gl-matrix-in-the-console">Practice: gl-matrix in the console</h4>
<ul>
<li>Open <code>index_2d_transform.html</code> in your browser and open the Console</li>
<li>Create a translation matrix</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">let</span> M_translation <span class="op">=</span> <span class="va">mat4</span>.<span class="at">fromTranslation</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="va">M_translation</span>.<span class="at">toString</span>()</a></code></pre></div>
<ul>
<li>Create a rotation matrix</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> M_rotation <span class="op">=</span> <span class="va">mat4</span>.<span class="at">fromZRotation</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> <span class="dv">45</span> <span class="op">*</span> <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="va">M_rotation</span>.<span class="at">toString</span>()</a></code></pre></div>
<ul>
<li>Combine the transformations by multiplication</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">let</span> M_RT <span class="op">=</span> <span class="at">mat4_matmul_many</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> M_translation<span class="op">,</span> M_rotation)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="va">M_RT</span>.<span class="at">toString</span>()</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">let</span> M_TR <span class="op">=</span> <span class="at">mat4_matmul_many</span>(<span class="va">mat4</span>.<span class="at">create</span>()<span class="op">,</span> M_rotation<span class="op">,</span> M_translation)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="va">M_TR</span>.<span class="at">toString</span>()</a></code></pre></div>
<ul>
<li>Check the resulting translation, is it the same?</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="va">mat4</span>.<span class="at">getTranslation</span>([<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>]<span class="op">,</span> M_RT)</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="va">mat4</span>.<span class="at">getTranslation</span>([<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>]<span class="op">,</span> M_TR)</a></code></pre></div>
</div>
<h2 id="task-1-2d-scene">Task 1: 2D Scene</h2>
<p>In this part we practice 2D transformations in the GPU pipeline on the example of simple triangles. This is the desired result. Please run <code>index_2d_transform.html</code> and edit <code>src/main_2d_transform.js</code>.</p>
<figure>
<video src="doc/icg_solar_2d_loop.webm" autoplay="true" loop="true" muted="true">
</video>
</figure>
<div class="box task">
<h3 id="task-1.1-2d-translation-in-shader">Task 1.1: 2D translation in shader</h3>
<p>We draw a blue triangle using the <code>draw_triangle_with_offset</code> pipeline. We want the triangle to be moved when we click and drag with the mouse. We provide code which tracks the mouse offset and store it in <code>mouse_offset</code>.</p>
<ul>
<li><p><strong>1.1.1</strong> Edit the <em>vertex shader</em> of <code>draw_triangle_with_offset</code> to apply translation to vertex position (no need to use a matrix here). Any compilation error of the shader program will be shown in the console.</p></li>
<li><p><strong>1.1.2</strong> Provide the mouse position and the color to the <code>draw_triangle_with_offset</code> call.</p></li>
</ul>
</div>
<div class="box task">
<h3 id="task-1.2-2d-matrix-transform">Task 1.2: 2D matrix transform</h3>
<p>We draw a green and blue triangles using the <code>draw_trinalge_with_transform</code> pipeline, which applies a transformation matrix to the triangle position.</p>
<ul>
<li><strong>1.2.1</strong> Edit the <em>vertex shader</em> of <code>draw_trinalge_with_transform</code> to apply the transform matrix <code>mat_transform</code> to the vertex position vector.</li>
<li><strong>1.2.2</strong> Construct a translation matrix for vector <code>[0.5, 0, 0]</code>, and a rotation around Z for angle <code>(time * 30 deg)</code>. Multiply the matrices in appropriate order and call the pipeline to draw:
<ul>
<li>A green triangle orbiting the center point</li>
<li>A red triangle spinning at <code>[0.5, 0, 0]</code></li>
</ul></li>
</ul>
</div>
<h2 id="task-2-solar-system">Task 2: Solar System</h2>
<p>In this part we create a 3D solar system visualization. Please run <code>index.html</code> and edit <code>src/main.js</code>.</p>
<figure>
<video src="doc/icg_solar_3d_loop.webm" autoplay="true" loop="true" muted="true">
</video>
</figure>
<h3 id="loading-resources">Loading resources</h3>
<p>Due to the <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">same-origin policy</a>, browsers by default do not allow textures to be loaded from local files (<code>file://</code> URL) and then used in JS. To overcome that, we host the site on a local server or change browser settings.</p>
<h4 id="local-web-server">Local web server</h4>
<p>If you have <code>python</code> installed, you can use its built-in web server to host the site at <a href="http://localhost:8000" class="uri">http://localhost:8000</a>. Run the following command in terminal:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1"><span class="bu">cd</span> ex4_gpu_transforms</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">python3</span> -m http.server</a></code></pre></div>
<p>The server post will be displayed:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1"><span class="ex">Serving</span> HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) <span class="ex">...</span></a></code></pre></div>
<p>Open <a href="http://localhost:8000/index.html" class="uri">http://localhost:8000/index.html</a> in your browser.</p>
<h4 id="browser-settings">Browser settings</h4>
<p>In <strong>Chrome</strong> you can allow loading data from <code>file://</code> using the <code>--allow-file-access-from-files</code> switch.</p>
<ul>
<li><p>Linux</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1"><span class="ex">chromium-browser</span> --allow-file-access-from-files index.html</a></code></pre></div></li>
<li><p>Windows</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" title="1"><span class="st">&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot;</span> <span class="ex">--allow-file-access-from-files</span> index.html</a></code></pre></div>
<p>If your <code>chrome.exe</code> is not found at this location, you can find it with</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1"><span class="ex">reg</span> query <span class="st">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe&quot;</span></a></code></pre></div></li>
</ul>
<p>In <strong>Firefox</strong> you can open <code>about:config</code> and set <code>ecurity.fileuri.strict_origin_policy</code> to <code>false</code>. Use a temporary profile or reset the setting later to avoid degrading the browser security.</p>
<h3 id="model-view-projection">Model-view-projection</h3>
<p>The vertex shader transforms the vertex positions from their original place in the model (mesh) to the final position in the output image.</p>
<p>This is done in several steps:</p>
<ul>
<li>Model matrix: transforms model to world coordinates (variable: <code>actor.mat_model_to_world</code>, where <em>actor</em> is the object holding information about the current model)</li>
<li>View matrix: transforms world coordinates into coordinates relative to the camera (variable: <code>mat_world_to_cam</code>)</li>
<li>Projection matrix: transforms from camera frame to the homogenous coordinates in the image (variable: <code>mat_projection</code>).</li>
</ul>
<figure>
<img src="doc/mvp_transform.svg"> </img>
</figure>
<p>There are further articles on that topic:</p>
<ul>
<li>Visualization: <a href="https://jsantell.com/model-view-projection">Model View Projection</a> by Jordan Santell</li>
<li>Example matrices: <a href="http://www.codinglabs.net/article_world_view_projection_matrix.aspx">World, View and Projection Transformation Matrices</a>.</li>
</ul>
<p>The projection matrix is already given in our code, we ask you to calculate the remaining steps and combine them into the final model-view-projection matrix.</p>
<div class="box task">
<h3 id="task-2.1-mvp-matrix">Task 2.1: MVP matrix</h3>
<ul>
<li><strong>2.1.1</strong> Edit the <em>vertex shader</em> of <code>draw_sphere</code> to apply the transform matrix <code>mat_mvp</code> to the vertex position vector. The solution is the same as <strong>1.2.1</strong>.</li>
<li><strong>2.1.2</strong> Calculate the MVP matrix <code>mat_mvp</code>. The model matrix is given as <code>actor.mat_model_to_world</code>, the view matrix is <code>mat_world_to_cam</code> and the projection is <code>mat_projection</code>.</li>
</ul>
</div>
<div class="box task">
<h3 id="task-2.2-view-matrix">Task 2.2: View matrix</h3>
<p>Construct the view matrix in the <code>update_cam_transform</code> function and store it in the variable <code>mat_world_to_cam</code>. We are using a “turntable” camera, it always looks at the origin point <code>[0, 0, 0]</code> and we can turn it around with the mouse.</p>
<ul>
<li>The distance from the camera to <code>[0, 0, 0]</code> is <code>r = cam_distance_base*cam_distance_factor</code>.</li>
<li>The angle between the camera’s forward-ray and the XY plane is <code>cam_angle_y</code>.</li>
<li>The XY plane is rotated by <code>cam_angle_z</code>.</li>
</ul>
<figure>
<img src="doc/camera_pos.svg" width="400"> </img>
</figure>
<p>It is convenient to create a view matrix with the <em>look-at</em> function <code>mat4.lookAt(out, eye, target, up)</code>. But you should also combine it with rotations to achieve the turn-table effect. <a href="https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function">More about the look-at function</a>.</p>
</div>
<div class="box task">
<h3 id="task-2.3-model-matrix">Task 2.3: Model matrix</h3>
<p>Construct the model matrix in the <code>calculate_actor_to_world_transform(actor)</code> function and store it in <code>actor.mat_model_to_world</code>.</p>
<ul>
<li><p>Each celestial body spins around its Z axis, the angle of rotation is <code>sim_time * actor.rotation_speed</code>.</p></li>
<li><p>The original mesh is a unit sphere, we scale it by <code>actor.size</code> to achieve the desired size.</p></li>
<li><p>Planets can orbit around other bodies. The parent body (around which we are orbiting) is stored in <code>actor.orbits</code>; the Sun’s parent is <code>null</code>. The parent’s model matrix is <code>actor.orbits.mat_model_to_world</code>, the orbit angle is <code>sim_time * actor.orbit_speed + actor.orbit_phase</code> and the radius <code>actor.orbit_radius</code>. Planets orbit in the XY plane.</p></li>
</ul>
</div>
<h2 id="what-to-submit">What to submit</h2>
<p>A .zip compressed file named <code>ExerciseN-GroupG.zip</code>, where <em>N</em> is the number of the current exercise sheet, and <em>G</em> is the number of your group. It should contain:</p>
<ul>
<li>The files you changed (in this case <code>src/main.js</code>, <code>src/main_2d_transform.js</code>).</li>
<li>A couple of screenshots clearly showing that you can display the planets, and that you can turn and zoom the camera.</li>
<li>A <code>readme.txt</code> file containing a description of how you solved each part of the exercise (use the same numbers and titles) and whatever problems you encountered. <em>Indicate what fraction of the total workload each project member contributed.</em></li>
</ul>
<p>Submit solutions to Moodle before the deadline. Late submissions receive 0 points!</p>
<div class="box grade">
<h3 id="grading">Grading</h3>
<ul>
<li><strong>10%</strong> Task 1.1: 2D translation in shader</li>
<li><strong>20%</strong> Task 1.2: 2D matrix transform 15%</li>
<li><strong>10%</strong> Task 2.1: MVP matrix</li>
<li><strong>30%</strong> Task 2.2: View matrix</li>
<li><strong>30%</strong> Task 2.3: Model matrix</li>
</ul>
</div>

</body> 
